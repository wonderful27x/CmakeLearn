# CmakeLearn
* Cmake code example from [cook-cmake](https://github.com/xiaoweiChen/CMake-Cookbook)
* Add understanding for myself

# Knowledge overview
## 第0章 配置环境

学习CMake之前，需要对系统进行设置，这样才能运行所有示例。

本章的主要内容有：

* 如何获取代码
* 如何在GNU/Linux、macOS和Windows上安装运行示例所需的所有工具
* 自动化测试如何工作
* 如何报告问题，并提出改进建议

我们会尽可能让初学者看懂本书的内容。不过，这本书并非完全适合零基础人士。我们假设，您对构建目标平台上可用的软件，及本地工具有基本的了解。有Git版本控制的经验，可与源码库进行“互动"(不是必需)。

## 第1章 从可执行文件到库

本章的主要内容有：

* 将单个源码文件编译为可执行文件
* 切换生成器
* 构建和连接静态库与动态库
* 用条件语句控制编译
* 向用户显示选项
* 指定编译器
* 切换构建类型
* 设置编译器选项
* 为语言设定标准
* 使用控制流进行构造

本章的示例将指导您完成构建代码所需的基本任务：编译可执行文件、编译库、根据用户输入执行构建操作等等。CMake是一个构建系统生成器，特别适合于独立平台和编译器。除非另有说明，否则所有配置都独立于操作系统，它们可以在GNU/Linux、macOS和Windows的系统下运行。

本书的示例主要为C++项目设计，并使用C++示例进行了演示，但CMake也可以用于其他语言的项目，包括C和Fortran。我们会尝试一些有意思的配置，其中包含了一些C++、C和Fortran语言示例。您可以根据自己喜好，选择性了解。有些示例是定制的，以突出在选择特定语言时需要面临的挑战。

# 第2章 检测环境

本章的主要内容有：

* 检测操作系统
* 处理与平台相关的源码
* 处理与编译器相关的源码
* 检测处理器体系结构
* 检测处理器指令集
* 为Eigen库使能向量化

尽管CMake跨平台，但有时源代码并不是完全可移植(例如：当使用依赖于供应商的扩展时)，我们努力使源代码能够跨平台、操作系统和编译器。这个过程中会发现，有必要根据平台不同的方式配置和/或构建代码。这对于历史代码或交叉编译尤其重要，我们将在第13章中讨论这个主题。了解处理器指令集也有助于优化特定目标平台的性能。本章会介绍，检测环境的方法，并给出建议。

# 第3章 检测外部库和程序

本章中主要内容有:

* 检测Python解释器
* 检测Python库
* 检测Python模块和包
* 检测BLAS和LAPACK数学库
* 检测OpenMP并行环境
* 检测MPI并行环境
* 检测Eigen库
* 检测Boost库
* 检测外部库:Ⅰ. 使用pkg-config
* 检测外部库:Ⅱ. 书写find模块

我们的项目常常会依赖于其他项目和库。本章将演示，如何检测外部库、框架和项目，以及如何链接到这些库。CMake有一组预打包模块，用于检测常用库和程序，例如：Python和Boost。可以使用`cmake --help-module-list`获得现有模块的列表。但是，不是所有的库和程序都包含在其中，有时必须自己编写检测脚本。本章将讨论相应的工具，了解CMake的`find`族命令:

* **find_file**：在相应路径下查找命名文件
* **find_library**：查找一个库文件
* **find_package**：从外部项目查找和加载设置
* **find_path**：查找包含指定文件的目录
* **find_program**：找到一个可执行程序

**NOTE**:*可以使用`--help-command`命令行显示CMake内置命令的打印文档。*

# 第4章 创建和运行测试

本章的主要内容有：

* 创建一个简单的单元测试
* 使用Catch2库进行单元测试
* 使用Google测试库进行单元测试
* 使用Boost测试进行单元测试
* 使用动态分析来检测内存缺陷
* 预期测试失败
* 使用超时测试运行时间过长的测试
* 并行测试
* 运行测试子集
* 使用测试固件

测试代码是开发工具的核心组件。通过单元测试和集成测试自动化测试，不仅可以帮助开发人员尽早回归功能检测，还可以帮助开发人员参与，并了解项目。它可以帮助新开发人员向项目代码提交修改，并确保预期的功能性。对于验证安装是否保留了代码的功能时，自动化测试必不可少。从一开始对单元、模块或库进行测试，可以使用一种纯函数式的风格，将全局变量和全局状态最小化，可让开发者的具有更模块化、更简单的编程风格。

本章中，我们将演示如何使用流行的测试库和框架，将测试集成到CMake构建结构中，并谨记以下目标：

* 让用户、开发人员和持续集成服务很容易地运行测试集。应该像使用`Unix Makefile`时，键入`make test`一样简单。
* 通过最小化测试时间，高效地运行测试，最大限度地提高运行测试的概率——理想情况下，每次代码修改都该如此。

# 第5章 配置时和构建时的操作

本章的主要内容有：

* 使用平台无关的文件操作
* 配置时运行自定义命令
* 构建时运行自定义命令:Ⅰ. 使用add_custom_command
* 构建时运行自定义命令:Ⅱ. 使用add_custom_target
* 构建时为特定目标运行自定义命令
* 探究编译和链接命令
* 探究编译器标志命令
* 探究可执行命令
* 使用生成器表达式微调配置和编译

我们将学习如何在配置和构建时，执行自定义操作。先简单回顾一下，与CMake工作流程相关的时序:

1. **CMake时**或**配置时**：CMake正在运行，并处理项目中的`CMakeLists.txt`文件。
2. **生成时**：生成构建工具(如Makefile或Visual Studio项目文件)。
3. **构建时**：由CMake生成相应平台的原生构建脚本，在脚本中调用原生工具构建。此时，将调用编译器在特定的构建目录中构建目标(可执行文件和库)。
4. **CTest时**或**测试时**：运行测试套件以检查目标是否按预期执行。
5. **CDash时**或**报告时**：当测试结果上传到仪表板上，与其他开发人员共享测试报告。
6. **安装时**：当目标、源文件、可执行程序和库，从构建目录安装到相应位置。
7. **CPack时**或**打包时**：将项目打包用以分发时，可以是源码，也可以是二进制。
8. **包安装时**：新生成的包在系统范围内安装。

完整的工作流程和对应的时序，如下图所示:

![](../../images/preface/2.png)

本章会介绍在配置和构建时的自定义行为，我们将学习如何使用这些命令:

* **execute_process**，从CMake中执行任意进程，并检索它们的输出。
* **add_custom_target**，创建执行自定义命令的目标。
* **add_custom_command**，指定必须执行的命令，以生成文件或在其他目标的特定生成事件中生成。

# 第6章 生成源码

本章的主要内容如下：

* 配置时生成源码
* 使用Python在配置时生成源码
* 构建时使用Python生成源码
* 记录项目版本信息以便报告
* 从文件中记录项目版本
* 配置时记录Git Hash值
* 构建时记录Git Hash值

大多数项目，使用版本控制跟踪源码。源代码通常作为构建系统的输入，将其转换为o文件、库或可执行程序。某些情况下，我们使用构建系统在配置或构建步骤时生成源代码。根据配置步骤中收集的信息，对源代码进行微调。另一个常用的方式，是记录有关配置或编译的信息，以保证代码行为可重现性。本章中，我们将演示使用CMake提供的源代码生成工具，以及各种相关的策略。

# 第7章 构建项目

本章的主要内容如下：

* 使用函数和宏重用代码
* 将CMake源代码分成模块
* 编写函数来测试和设置编译器标志
* 用指定参数定义函数或宏
* 重新定义函数和宏
* 废弃使用函数、宏和变量
* add_subdirectory的限定范围
* 使用target_sources避免全局变量
* 组织Fortran项目

前几章中，我们已经使用了一些CMake构建块来配置和构建的项目。本章中，我们将讨论如何组合这些构建块，并引入抽象，并最小化代码重复、全局变量、全局状态和显式排序，以免CMakeLists.txt文件过于庞大。目标是为模块化CMake代码结构和限制变量范围提供模式。我们将讨论一些策略，也将帮助我们控制中大型代码项目的CMake代码复杂性。

# 第8章 超级构建模式

本章的主要内容如下：

* 使用超级级构建模式
* 使用超级构建管理依赖项:Ⅰ.Boost库
* 使用超级构建管理依赖项:Ⅱ.FFTW库
* 使用超级构建管理依赖项:Ⅲ.Google测试框架
* 使用超级构建支持项目

每个项目都需要处理依赖关系，使用CMake很容易查询这些依赖关系，是否存在于配置项目中。第3章，展示了如何找到安装在系统上的依赖项，到目前为止我们一直使用这种模式。但是，当不满足依赖关系，我们只能使配置失败，并向用户警告失败的原因。然而，使用CMake可以组织我们的项目，如果在系统上找不到依赖项，就可以自动获取和构建依赖项。本章将介绍和分析` ExternalProject.cmake`和`FetchContent.cmake `标准模块，及在超级构建模式中的使用。前者允许在构建时检索项目的依赖项，后者允许我们在配置时检索依赖项(CMake的3.11版本后添加)。使用超级构建模式，我们可以利用CMake作为包管理器：相同的项目中，将以相同的方式处理依赖项，无论依赖项在系统上是已经可用，还是需要重新构建。接下来的5个示例，将带您了解该模式，并展示如何使用它来获取和构建依赖关系。

**NOTE**:*这两个模块都有大量的在线文档。`ExternalProject.cmake`，可以参考https://cmake.org/cmake/help/v3.5/module/ExternalProject.html 。`FetchContent.cmake`，可以参考https://cmake.org/cmake/help/v3.11/module/FetchContent.html 。*

# 第9章 语言混合项目

本章的主要内容如下：

* 使用C/C++库构建Fortran项目
* 使用Fortran库构建C/C++项目
* 使用Cython构建C++和Python项目
* 使用Boost.Python构建C++和Python项目
* 使用pybind11构建C++和Python项目
* 使用Python CFFI混合C，C++，Fortran和Python

有很多的库比较适合特定领域的任务。我们的库直接使用这些专业库，是一中快捷的方式，这样就可以使用来自其他专家组的多年经验进行开发。随着计算机体系结构和编译器的发展，编程语言也在不断发展。几年前，大多数科学软件都是用Fortran语言编写的，而现在，C、C++和解释语言——Python——正占据着语言中心舞台。将编译语言代码与解释语言的代码集成在一起，变得确实越来越普遍，这样做有以下好处:

* 用户可以需要进行定制和扩展功能，以满足需求。
* 可以将Python等语言的表达能力与编译语言的性能结合起来，后者在内存寻址方面效率接近于极致，达到两全其美的目的。

正如我们之前的示例中展示的那样，可以使用`project`命令通过`LANGUAGES`关键字设置项目中使用的语言。CMake支持许多(但不是所有)编译的编程语言。从CMake 3.5开始，各种风格的汇编(如ASM-ATT，ASM，ASM-MASM和ASM- NASM)、C、C++、Fortran、Java、RC (Windows资源编译器)和Swift都可以选择。CMake 3.8增加了对另外两种语言的支持：C#和CUDA(请参阅发布说明:https://cmake.org/cmake/help/v3.8/release/3.8.html#languages )。

本章中，我们将展示如何以一种可移植且跨平台的方式集成用不同编译(C、C++和Fortran)和解释语言(Python)编写的代码。我们将展示如何利用CMake和一些工具集成不同编程语言。

# 第10章 编写安装程序

本章主要内容：

* 安装项目
* 生成输出头文件
* 输出目标
* 安装超级构建

前几章中，我们展示了如何使用CMake配置、构建和测试项目。安装项目是很重要的一部分，本章将演示如何实现这一点。本章涵盖了下图中，安装时的所有操作:

![](../../images/preface/2.png)

我们将指导完成各个步骤，直到完成安装一个简单的C++项目：从项目中构建的文件，并复制到正确的目录，确保其他项目使用CMake时可以找到该工程的输出目标。本章中的4个示例将建立在第1章第3节的示例基础上。之前，我们试图构建一个非常简单的库，并将其链接到一个可执行文件中。我们还展示了如何使用相同的源文件构建静态库和动态库。本章中，我们将会讨论安装时所发生的事情。

# 第11章 打包项目

本章的主要内容有：

* 生成源代码和二进制包
* 使用CMake/pybind11构建的C++/Python项目，通过PyPI发布
* 使用CMake/CFFI构建C/Fortran/Python项目，通过PyPI发布
* 以Conda包的形式发布一个简单的项目
* 将Conda包作为依赖项发布给项目

目前为止，已经从源代码编译并安装了软件包——这意味着可以通过Git获取项目，并手动执行配置、构建、测试和安装。然而，在实际中，软件包通常是使用管理器来安装的，比如Apt、DNF、Pacman、pip和Conda。我们需要以各种格式发布我们的代码项目——作为源文件或二进制安装程序。

下图显示了使用CMake的项目的各个阶段，我们现在方案就是其中的打包时(PI)：

![](../../images/preface/2.png)

本章中，我们将探讨不同的打包策略。首先，讨论使用CMake中的工具CPack进行打包，还提供打包和上传CMake项目到Python包索引(PyPI, https://pypi.org)和Anaconda云(https://anaconda.org )的方法，这些都是通过包管理器pip和Conda (https://conda.io/docs/ )分发包的平台。对于PyPI，我们将演示如何打包和分发混合C++/Python或C/Fortran/Python的项目。对于Conda，我们将展示如何对依赖于其他库的C++项目进行打包。

# 第12章 构建文档

本章的主要内容有：

* 使用Doxygen构建文档
* 使用Sphinx构建文档
* 结合Doxygen和Sphinx

文档在所有的软件项目都是有必要的：对于用户来说，了解如何获得并构建代码，并且如何有效地使用源代码或库；对于开发人员来说，文档可用来描述你源码细节，并帮助其他程序员参与其中为该项目作出贡献。本章将展示如何使用CMake构建代码文档，这里使用了两个流行的文档框架：Doxygen和Sphinx。

# 第13章 选择生成器和交叉编译

本章主要内容有：

* 使用Visual Studio 2017构建CMake项目
* 交叉编译hello world示例
* 使用OpenMP并行化交叉编译Windows二进制文件

CMake本身不构建可执行程序和库。不过，CMake配置一个项目，并生成构建工具或框架用于构建项目的文件。在GNU/Linux和macOS上，CMake通常生成Unix Makefile(也存在替代方式)。在Windows上，通常生成Visual Studio项目文件或MinGW或MSYS Makefile。CMake包括本地构建工具或集成开发环境(IDE)的生成器。可以通过以下链接阅读更多关于它们的信息:https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html

可以使用`cmake -G`的方式来选择生成器：

```shell
$ cmake -G "Visual Studio 15 2017"
```

不是每个平台上所有的生成器都可用，而且CMake在运行时获取平台信息。要查看当前平台上所有可用生成器的列表，请键入以下命令：

```shell
$ cmake -G
```

在本章中，我们不会使用所有生成器，但是本书中的大多数示例都使用了Unix Makefile、MSYS Makefile、Ninja和Visual Studio 15 2017进行了测试。

我们将重点讨论Windows平台上的开发，将演示不使用命令行，如何使用Visual Studio 15 2017直接构建CMake项目。还会讨论如何在Linux或macOS系统上，交叉编译Windows的可执行文件。

# 第14章 测试面板

本章的主要内容有：

* 将测试部署到CDash面板
* CDash面板显示测试覆盖率
* 使用AddressSanifier向CDash报告内存缺陷
* 使用ThreadSaniiser向CDash报告数据争用

CDash是一个web服务，用于汇集CTest在测试运行期间、夜间测试期间或在持续集成中的测试结果。面板报告就是我们所说的**CDash时**，如下图所示：

![](../../images/preface/2.png)

本章中，我们将向CDash报告测试结果。将讨论报告测试覆盖率的策略，以及分别使用AddressSanifier和ThreadSanifier等工具，收集的内存缺陷和数据争用问题。

有两种方法向CDash报告结果：

1. 通过构建的测试目标
2. 使用CTest脚本

在前两个示例中使用建立测试目标的方式，在后两个示例中使用CTest脚本。

## CDash环境

CDash的安装需要使用PHP和SSL的web服务器(Apache、NGINX或IIS)，并访问MySQL或PostgreSQL数据库服务器。详细讨论CDash web服务的设置超出了本书的范围，读者们可以参考官方文档：https://public.kitware.com/Wiki/CDash:Installation

Kitware提供了两个面板(https://my.cdash.org 和 https://open.cdash.org )，因此本章中的示例并不需要安装CDash。我们将在示例中参考已经提供的面板。

对于想要自己安装CDash的读者，我们建议使用MySQL作为后端，因为这是 https://my.cdash.org 和 https://open.cdash.org 的配置方式，而且社区也对这种搭配方式进行了测试。

**NOTE**:*也可以使用Docker来安装CDash。官方镜像的请求在CDash的跟踪器上处于打开状态，网址是https://github.com/Kitware/CDash/issues/562*

# 第15章 使用CMake构建已有项目

在本书的最后一章中，我们将结合前几章中讨论过的许多不同的构建块，并将它们应用到实际项目中。我们的目标是一步一步地演示如何将一个重要的项目使用CMake进行构建。提供关于移植项目或将CMake添加到遗留代码的建议(无论是来自Autotools、手工编写的配置脚本和Makefile，还是来自Visual Studio)。

为了得到一个实际示例，我们将使用Vim编辑器(https://www.vim.org )的源代码，并尝试将配置和编译，从Autotools迁移到CMake。

为了使讨论和示例相对简单，我们不会将整个Vim项目迁移到CMake，而是挑出最重要的部分。只构建Vim的核心版本，不支持图形用户界面(GUI)。我们将获取能够编译的Vim源码版本，并使用CMake，用书中介绍的其他工具进行配置、构建和测试。

本章主要有以下内容：

* 如何开始迁移项目
* 生成文件并编写平台检查
* 检测所需的依赖关系和链接
* 复制编译标志
* 移植测试
* 移植安装目标
* 项目转换为CMake的常见问题

# 第16章 可能感兴趣的书

如果你喜欢本书，你可能会对Packt的其他书感兴趣:

![](../../images/chapter16/16-1.png)

**Mastering Qt 5 - Second Edition**

Guillaume Lazar, Robin Penea

ISBN: 978-1-78899-539-9

* 使用Qt Widgets和Qt Quick 2创建漂亮的UI
* 使用Qt框架开发功能强大的跨平台应用程序
* 使用Qt设计器设计GUI，并在其中构建用于UI预览的库
* 在C++中处理用户与Qt信号/插槽机制的交互
* 准备跨平台项目来托管第三方库
* 使用Qt动画框架来创造惊人的效果
* 使用Qt和嵌入式平台部署移动应用程序
* 使用Qt Gamepad与游戏平板交互

![](../../images/chapter16/16-2.png)

**Learn QT 5**

Nicholas Sherriff

ISBN: 978-1-78847-885-4

* 安装/配置Qt框架和Qt Creator IDE
* 使用QMake控制创建一个新的多项目解决方案
* 用QML实现一个丰富的用户界面
* 学习QtTest的基础知识，以及如何集成单元测试
* 构建自我感知的数据实体，这些数据实体和JSON进行互相转换
* 使用SQLite和CRUD管理数据
* 接触互联网并使用RSS
* 生成应用程序包以分发给其他用户
